{"meta":{"title":"哈哈娃前端","subtitle":null,"description":"开发笔记整理","author":"哈哈娃","url":"http://yoursite.com"},"pages":[{"title":"404","date":"2018-12-17T15:35:22.203Z","updated":"2018-12-17T15:35:22.203Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""}],"posts":[{"title":"2018/12/18/vue-ssr初探","slug":"2018-12-18-vue-ssr初探","date":"2018-12-17T15:45:38.000Z","updated":"2018-12-17T16:22:51.065Z","comments":true,"path":"2018/12/17/2018-12-18-vue-ssr初探/","link":"","permalink":"http://yoursite.com/2018/12/17/2018-12-18-vue-ssr初探/","excerpt":"","text":"VUE-SSR 主要思路1、将应用分为两个入口，分别为entry-client.js和entry-server.js，给两个入口配置独立的webpack配置。需要注意的是server需要设置target: ‘node’和libraryTarget: ‘commonjs2’，因为server入口是跑在node层的，需要遵循commonjs规范2、用Webpack把整个应用单独打一个包3、Node环境通过vue-server-renderer API将这个包加载到vm环境当中4、应用在vm内部启动HTTP请求抓取当前路由依赖的数据，如果页面不为单页应用，可以把路由的逻辑改为组件加载的逻辑，即组件里的syncData获取完渲染页面5、生成网页模板, 将HTML和初始数据嵌在中间 数据策略对于依赖数据，方案是在组件定义上提供syncData函数，服务端渲染时会主动查找挂载的部分，调用这个函数进行数据抓取，最后将所有数据设置到vuex的state中。如果使用vue-router，即是在每次路由加载之前拿到对应的syncData函数，将这些函数(函数本身返回new Promise)push到一个执行promise队列中去，最后使用Promis.all执行，等所有数据都拿到后去渲染页面。如果没有使用vue-router，只是一个页面，那么就是利用App.components拿到所有的依赖组件，从而获取组件中的syncData数据，后续与上面一致。 缓存优化利用lru-cache这个包实现\b缓存 1、页面缓存就是判断页面的url是否命中缓存中的一个，如果命中就用缓存的，核心代码如下：1234567891011121314151617181920212223242526272829303132333435363738const LRU = require('lru-cache')const microCache = LRU(&#123; max: 100, // 最大缓存的数目 maxAge: 1000 // 重要提示：条目在 1 秒后过期。&#125;) const isCacheable = req =&gt; &#123; //判断是否需要页面缓存 if (req.url &amp;&amp; req.url === '/') &#123; return req.url &#125; else &#123; return false &#125;&#125;app.get('*', (req, res) =&gt; &#123; const cacheable = isCacheable(req) if (cacheable) &#123; const hit = microCache.get(req.url) if (hit) &#123; return res.end(hit) &#125; &#125;const context = &#123; title: 'vue', keywords: 'vue-ssr服务端脚手架', description: 'vue-ssr-template, vue-server-renderer', version: '1.0', url: req.url, cookies: req.cookies&#125;;renderer.renderToString(context, (err, html) =&gt; &#123; if (err) &#123; return errorHandler(err) &#125; res.end(html); microCache.set(req.url, html) // 设置当前缓存页面的内容&#125;); 2、组件缓存server.js12345678910111213function createRenderer(bundle, template) &#123; return require('vue-server-renderer').createBundleRenderer(bundle, &#123; template, cache: LRU(&#123; max: 1000, maxAge: 1000 * 60 * 5 // 组建缓存时间 &#125;); &#125;);&#125;let rendererconst bundle = require('./output/vue-ssr-bundle.json');const template = fs.readFileSync(resolve('./output/index.html'), 'utf-8');renderer = createRenderer(bundle, template); componet.vue123456789101112131415export default &#123; name: 'Home', title() &#123; return &#123; title: 'vue-ssr', keywords: 'vue-ssr服务端脚手架, home', description: 'vue-ssr-template, vue-server-renderer, home' &#125; &#125;, created() &#123; &#125;, computed: &#123;&#125;, asyncData(&#123; store &#125;) &#123;&#125;, methods: &#123;&#125;, serverCacheKey: props =&gt; props.id \bserverCacheKey 返回的 key 应该包含足够的信息，来表示渲染结果的具体情况。如果渲染结果仅由 props.item.id 决定，则上述是一个很好的实现。但是，如果具有相同 id 的 item 可能会随时间而变化，或者如果渲染结果依赖于其他 prop，则需要修改 serverCacheKey 的实现，以考虑其他变量。如果 serverCacheKey返回常量将导致组件始终被缓存，这对纯静态组件是有好处的。 3、接口缓存和页面缓存很想，也是用当前的url的做key(作为key需要设置一次编码，如md5)设置缓存，\b命中则用缓存。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"vue ssr","slug":"vue-ssr","permalink":"http://yoursite.com/tags/vue-ssr/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"几种常见的css布局","slug":"几种常见的css布局","date":"2018-03-14T03:02:16.000Z","updated":"2018-12-17T15:35:22.217Z","comments":true,"path":"2018/03/14/几种常见的css布局/","link":"","permalink":"http://yoursite.com/2018/03/14/几种常见的css布局/","excerpt":"","text":"左边固定，右边自适应 1、flex1234&lt;div style=\"display: flex;height: 50px;\"&gt; &lt;div style=\"width: 200px;background: green\"&gt;&lt;/div&gt; &lt;div style=\"flex: 1;background: red\"&gt;&lt;/div&gt;&lt;/div&gt; 2、float+margin1234&lt;div&gt; &lt;div style=\"width: 200px;background: green;float:left;height: 50px;\"&gt;&lt;/div&gt; &lt;div style=\"background: red;margin-left:200px;height: 50px;\"&gt;&lt;/div&gt;&lt;/div&gt; 3、float+overflow1234&lt;div&gt; &lt;div style=\"width: 200px;background: green;float:left;height: 50px;\"&gt;&lt;/div&gt; &lt;div style=\"background: red;overflow: hidden;height: 50px;\"&gt;&lt;/div&gt;&lt;/div&gt; 4、table1234&lt;div style=\"display: table;width: 100%; table-layout: fixed;\"&gt; &lt;div style=\"width: 200px;background: green;height: 50px;display: table-cell;\"&gt;&lt;/div&gt; &lt;div style=\"background: red;height: 50px;display: table-cell;\"&gt;&lt;/div&gt;&lt;/div&gt; 右边固定，左边自适应1、flex1234&lt;div style=\"display: flex;height: 50px;\"&gt; &lt;div style=\"flex: 1;background: red;\"&gt;&lt;/div&gt; &lt;div style=\"width: 200px;background: green;\"&gt;&lt;/div&gt;&lt;/div&gt; 2、float+margin1234&lt;div&gt; &lt;div style=\"background: red;float:left;width:100%;margin-right:-200px;height: 50px;\"&gt;&lt;/div&gt; &lt;div style=\"width: 200px;background: green;float:right;height: 50px;\"&gt;&lt;/div&gt;&lt;/div&gt; 3、table1234&lt;div style=\"display: table;width: 100%; table-layout: fixed;\"&gt; &lt;div style=\"background: red;height: 50px;display: table-cell;\"&gt;&lt;/div&gt; &lt;div style=\"width: 200px;background: green;height: 50px;display: table-cell;\"&gt;&lt;/div&gt;&lt;/div&gt; 两侧固定，中间自适应1、flex12345&lt;div style=\"display: flex;height: 50px;\"&gt; &lt;div style=\"width: 200px;background: red;\"&gt;&lt;/div&gt; &lt;div style=\"background: blue; flex: 1;\"&gt;&lt;/div&gt; &lt;div style=\"width: 200px;background: green;\"&gt;&lt;/div&gt;&lt;/div&gt; 2、float+margin12345&lt;div style=\"overflow: hidden;\"&gt; &lt;div style=\"width: 200px;float: left;background: red;height: 50px;\"&gt;&lt;/div&gt; &lt;div style=\"background: blue;height: 50px;float: left;width: 100%;margin-right: -400px;\"&gt;&lt;/div&gt; &lt;div style=\"width: 200px;float: left;background: green;height: 50px;\"&gt;&lt;/div&gt;&lt;/div&gt; 3、table12345&lt;div style=\"display: table;;width: 100%;table-layout: fixed;\"&gt; &lt;div style=\"width: 200px;display:table-cell;background: red;height: 50px;\"&gt;&lt;/div&gt; &lt;div style=\"background: blue;height: 50px;\"&gt;&lt;/div&gt; &lt;div style=\"width: 200px;display:table-cell;background: green;height: 50px;\"&gt;&lt;/div&gt;&lt;/div&gt; 多列等分布局1、flex123456&lt;div style=\"display: flex;height: 50px;\"&gt; &lt;div style=\"flex: 1;background: red;\"&gt;&lt;/div&gt; &lt;div style=\"background: blue; flex: 1;\"&gt;&lt;/div&gt; &lt;div style=\"flex: 1;background: green;\"&gt;&lt;/div&gt; &lt;div style=\"flex: 1;background: yellow;\"&gt;&lt;/div&gt;&lt;/div&gt; 2、float123456&lt;div&gt; &lt;div style=\"width: 25%;background: red;float: left;height: 50px;\"&gt;&lt;/div&gt; &lt;div style=\"width: 25%;background: blue; float: left;height: 50px;\"&gt;&lt;/div&gt; &lt;div style=\"width: 25%;background: green;float: left;height: 50px;\"&gt;&lt;/div&gt; &lt;div style=\"width: 25%;background: yellow;float: left;height: 50px;\"&gt;&lt;/div&gt;&lt;/div&gt; 3、table123456&lt;div style=\"display: table;width: 100%;table-layout: fixed;height: 50px;\"&gt; &lt;div style=\"display: table-cell;background: red;\"&gt;&lt;/div&gt; &lt;div style=\"display: table-cell;background: blue;\"&gt;&lt;/div&gt; &lt;div style=\"display: table-cell;background: green;\"&gt;&lt;/div&gt; &lt;div style=\"display: table-cell;background: yellow;\"&gt;&lt;/div&gt;&lt;/div&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"实现vue的$on、$once、$off和$emit事件机制","slug":"实现vue的$on、$once、$off和$emit事件机制","date":"2018-03-13T08:43:27.000Z","updated":"2018-12-17T15:35:22.217Z","comments":true,"path":"2018/03/13/实现vue的$on、$once、$off和$emit事件机制/","link":"","permalink":"http://yoursite.com/2018/03/13/实现vue的$on、$once、$off和$emit事件机制/","excerpt":"","text":"这几天利用空闲的时间了解了一下vue的源代码，学习了vue的内部实现，真的获益匪浅。然后就自己实现了类似于vue事件机制的功能代码，加强自己的编码能力。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Event&#123; constructor() &#123; this._events = Object.create(null); &#125; $on(event,fn) &#123; if(Array.isArray(event)) &#123; //如果传的是数组就递归为每个成员绑定方法 for(let i = 0; i &lt; event.length; i++) &#123; this.$on(event[i],fn); &#125; &#125;else &#123; (this._events[event] || (this._events[event] = [])).push(fn); &#125; &#125; $off(event,fn) &#123; if (!arguments.length) &#123; //没传参数则全部销毁、 this._events = Object.create(null); return &#125; if (Array.isArray(event)) &#123; //数组则递归销毁 for(let i = 0; i &lt; event.length; i++) &#123; this.$off(event[i],fn); &#125; return &#125; // 特殊处理event const cbs = this._events[event]; if (!cbs) &#123; //如果不存在就返回 return &#125; if(arguments.length === 1) &#123; //如果只传了event参数，则销毁event下的所有方法 this._events[event] = null; return &#125; // 特殊处理fn /*遍历所有方法找到对应方法删除*/ let cb; let i = cbs.length - 1; while(i &gt;= 0) &#123; cb = cbs[i]; if (cb === fn || cb.fn === fn) &#123; cbs.splice(i,1) break; &#125; i -- &#125; &#125; $once(event,fn) &#123; function on () &#123; //每次执行事件先销毁 this.$off(event,on); //执行handler fn.apply(this,arguments) &#125; this.$on(event,on); &#125; $emit(event,arg) &#123; let cbs = this._events[event]; let args = Array.from(Array.prototype.splice.call(arguments,1,arguments.length-1)); if (cbs) &#123; cbs = cbs.length &gt; 1 ? Array.from(cbs) : cbs; for (let i = 0; i &lt; cbs.length; i++) &#123; cbs[i].apply(this,args); &#125; &#125; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"几个常用的js继承","slug":"几个常用的js继承","date":"2018-03-13T05:59:14.000Z","updated":"2018-12-17T15:35:22.216Z","comments":true,"path":"2018/03/13/几个常用的js继承/","link":"","permalink":"http://yoursite.com/2018/03/13/几个常用的js继承/","excerpt":"","text":"写了三个比较常用的js继承，作为一个小的笔记方便以后查看。组合式继承12345678910111213141516171819202122232425262728293031323334353637function A(name) &#123; this.name = name; this.age = 12; this.colors= [1,2]&#125;A.prototype.getName = function() &#123; console.log(this.name)&#125;function B(name,height) &#123; A.call(this,name); //调用基类构造方法，使用call将this指向派生类 this.height = height;&#125;B.prototype = new A();B.prototype.constructor = A;B.prototype.getHeight = function () &#123; console.log(this.height)&#125;var a = new A('CC');var b = new B('BB',169);b.getHeight();b.getName();b.colors.push(3);console.log(a.name)var c = new B('AA',170);c.getHeight();c.getName();c.colors.push(4);console.log(b.colors);console.log(c.colors); 寄生组合式继承12345678910111213141516171819202122232425function inherit(parent, child) &#123; var p = parent.prototype; p.constructor = parent; child.prototype = p;&#125;function A(name) &#123; this.name = name; this.age = 19;&#125;function B(name)&#123; A.call(this,name);&#125;inherit(A,B);B.prototype.getB = function() &#123; console.log(this.name);&#125;var b = new B('HH');b.getB();console.log(b.age); ES6继承1234567891011121314151617181920212223242526272829303132class A &#123; constructor(name)&#123; this.name = name; this.age = 21; &#125; getName() &#123; console.log(this.name) &#125; getAge() &#123; console.log(this.age) &#125;&#125;class B extends A&#123; constructor(name, height) &#123; super(); //相当于 A.protoytype.constructor.call(this) this.name = name; this.height = height; &#125; getHeight() &#123; console.log(this.height) &#125;&#125;let bb = new B('CCC',198);bb.getName();bb.getAge();bb.age = 22;bb.getAge();bb.getHeight();let aa = new A('AA');aa.getAge();","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"React中key的讲解","slug":"React中key的讲解","date":"2018-03-07T02:48:45.000Z","updated":"2018-12-17T15:35:22.215Z","comments":true,"path":"2018/03/07/React中key的讲解/","link":"","permalink":"http://yoursite.com/2018/03/07/React中key的讲解/","excerpt":"","text":"通过阅读React的文档我们知道React这个框架的核心思想是，将页面分割成一个个组件，一个组件还可能嵌套更小的组件，每个组件有自己的数据（属性/状态）;当某个组件的数据发生变化时，更新该组件部分的视图。更新的过程是由数据驱动的，新的数据自该组件顶层向下流向子组件，每个组件调用自己的render方法得到新的视图，并与之前的视图作diff-比较差异，完成更新，这是react实现的diff算法。这个过程就叫作reconciliation-调和。 React通过virtual dom来实现高效的视图更新。基本原理是用纯js对象模拟dom树，每当更新时，根据组件们的render方法计算出新的虚拟dom树，并与此前的虚拟dom树作diff，得到一个patch（差异补丁），最后映射到真实dom树上完成视图更新。而两棵树的完全的 diff 算法是一个时间复杂度为 O(n^3)的问题。但是在前端当中，很少出现跨越层级移动DOM元素的情况，所以React采用了简化的diff算法，只会对virtual dom中同一个层级的元素进行对比，这样算法复杂度就可以达到 O(n)。 由于React采用的diff算法是对新旧虚拟dom树同层级的元素挨个比较，碰到循环输出的元素时会有一些问题，比如列表。先来看一个例子：1234567891011// 旧v-dom&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;// 新v-dom&lt;ul&gt; &lt;li&gt;zero&lt;/li&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt; React在diff两棵树时，发现原来的两个li元素都与新v-dom中对应位置上的两个li元素不同，就会对其修改，并向真实dom树中插入新的second节点。实际上，我们可能只是进行了在first之前插入新zero节点的操作，而现在进行了额外的修改操作。React官方文档提示我们应该使用key属性来解决上述问题。key是一个字符串，用来唯一标识同父同层级的兄弟元素。当React作diff时，只要子元素有key属性，便会去原v-dom树中相应位置（当前横向比较的层级）寻找是否有同key元素，比较它们是否完全相同，若是则复用该元素，免去不必要的操作。延续第一个例子，如果每个li元素都有key属性：1234567891011// 旧v-dom&lt;ul&gt; &lt;li key=\"1\"&gt;first&lt;/li&gt; &lt;li key=\"2\"&gt;second&lt;/li&gt;&lt;/ul&gt;// 新v-dom&lt;ul&gt; &lt;li key=\"0\"&gt;zero&lt;/li&gt; &lt;li key=\"1\"&gt;first&lt;/li&gt; &lt;li key=\"2\"&gt;second&lt;/li&gt;&lt;/ul&gt; 现在React就知道了，新增了key为”0”的元素，而”1”与”2”仅仅移动了位置。key必须是字符串类型，它的取值可以用数据对象的某个唯一属性，或是对数据进行hash来生成key。123&lt;ul&gt; &#123;list.map(v=&gt; &lt;li key=&#123;v.idProp&#125;&gt;&#123;v.text&#125;&lt;/li&gt;)&#125;&lt;/ul&gt; 但是强烈不推荐用数组index来作为key。如果数据更新仅仅是数组重新排序或在其中间位置插入新元素，那么视图元素都将重新渲染。来看下例子：12345678910111213&lt;ul&gt;&#123;list.map((v,idx)=&gt;&lt;li key=&#123;idx&#125;&gt;&#123;v&#125;&lt;/li&gt;)&#125;&lt;/ul&gt;// ['a','b','c']=&gt;&lt;ul&gt; &lt;li key=\"0\"&gt;a&lt;/li&gt; &lt;li key=\"1\"&gt;b&lt;/li&gt; &lt;li key=\"2\"&gt;c&lt;/li&gt;&lt;/ul&gt;// 数组重排 -&gt; ['c','a','b'] =&gt;&lt;ul&gt; &lt;li key=\"0\"&gt;c&lt;/li&gt; &lt;li key=\"1\"&gt;a&lt;/li&gt; &lt;li key=\"2\"&gt;b&lt;/li&gt;&lt;/ul&gt; React发现key为0,1,2的元素的text都变了，将会修改三者的html，而不是移动它们。 文章参考至zenggo曾狗","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Vue中data为什么必须是函数","slug":"Vue中data为什么必须是函数","date":"2018-03-02T04:11:30.000Z","updated":"2018-12-17T15:35:22.216Z","comments":true,"path":"2018/03/02/Vue中data为什么必须是函数/","link":"","permalink":"http://yoursite.com/2018/03/02/Vue中data为什么必须是函数/","excerpt":"","text":"在vue中每个组件都是一个vue实例，如果在一个组件的两个实例同时出现在一起，而两个使用的是对象data，那么它们的引用使用的是同一个，当一个data改变的时候就会导致另一个的改变。具体原因如下：构造 Vue 实例时传入的各种选项大多数都可以在组件里使用。只有一个例外：data 必须是函数。实际上，如果你这么做：123456Vue.component('my-component', &#123; template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;', data: &#123; message: 'hello' &#125;&#125;) 那么 Vue 会停止运行，并在控制台发出警告，告诉你在组件实例中 data 必须是一个函数。但理解这种规则为何存在也是很有益处的，所以让我们先作个弊：12345&lt;div id=\"example-2\"&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt; 1234567891011121314var data = &#123; counter: 0 &#125;Vue.component('simple-counter', &#123; template: '&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', // 技术上 data 的确是一个函数了，因此 Vue 不会警告， // 但是我们却给每个组件实例返回了同一个对象的引用 data: function () &#123; return data &#125;&#125;)new Vue(&#123; el: '#example-2'&#125;) 由于这三个组件实例共享了同一个 data 对象，因此递增一个 counter 会影响所有组件！这就错了。我们可以通过为每个组件返回全新的数据对象来修复这个问题：12345data: function () &#123; return &#123; counter: 0 &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"JSEncrypt长文本分段加解密","slug":"JSEncrypt长文本分段加解密","date":"2018-02-05T05:54:30.000Z","updated":"2018-12-17T15:35:22.215Z","comments":true,"path":"2018/02/05/JSEncrypt长文本分段加解密/","link":"","permalink":"http://yoursite.com/2018/02/05/JSEncrypt长文本分段加解密/","excerpt":"","text":"需求出发点在进行RSA加密中，由于RSA的特性，一个1024位的密钥只能加密117位字节数据，当数据量超过117位字节的时候，程序就会抛出异常，下面就给出如何完成前端RSA分段解密和后端RSA分段解密。js加密库使用的是比较成熟的JSEncrypted，地址是https://github.com/travist/jsencrypt/tree/master/bin 下载相应的js文件。 代码开发对于加密我的方法就是判断字符的特性，然后进行分段处理，循环加密处理。每次加密117bytes，最后合为一体。代码及注释如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 长文本加密 * @param &#123;string&#125; string 待加密长文本 * @returns &#123;string&#125; 加密后的base64编码 * */ JSEncrypt.prototype.encryptLong = function (string) &#123; var k = this.getKey(); try &#123; var ct = \"\"; //RSA每次加密117bytes，需要辅助方法判断字符串截取位置 //1.获取字符串截取点 var bytes = new Array(); bytes.push(0); var byteNo = 0; var len, c; len = string.length; var temp = 0; for (var i = 0; i &lt; len; i++) &#123; c = string.charCodeAt(i); if (c &gt;= 0x010000 &amp;&amp; c &lt;= 0x10FFFF) &#123; //特殊字符，如Ř，Ţ byteNo += 4; &#125; else if (c &gt;= 0x000800 &amp;&amp; c &lt;= 0x00FFFF) &#123; //中文以及标点符号 byteNo += 3; &#125; else if (c &gt;= 0x000080 &amp;&amp; c &lt;= 0x0007FF) &#123; //特殊字符，如È，Ò byteNo += 2; &#125; else &#123; // 英文以及标点符号 byteNo += 1; &#125; if ((byteNo % 117) &gt;= 114 || (byteNo % 117) == 0) &#123; if (byteNo - temp &gt;= 114) &#123; bytes.push(i); temp = byteNo; &#125; &#125; &#125; //2.截取字符串并分段加密 if (bytes.length &gt; 1) &#123; for (var i = 0; i &lt; bytes.length - 1; i++) &#123; var str; if (i == 0) &#123; str = string.substring(0, bytes[i + 1] + 1); &#125; else &#123; str = string.substring(bytes[i] + 1, bytes[i + 1] + 1); &#125; var t1 = k.encrypt(str); ct += t1; &#125; ; if (bytes[bytes.length - 1] != string.length - 1) &#123; var lastStr = string.substring(bytes[bytes.length - 1] + 1); ct += k.encrypt(lastStr); &#125; return hex2b64(ct); &#125; var t = k.encrypt(string); var y = hex2b64(t); return y; &#125; catch (ex) &#123; return false; &#125; &#125;; 如果后台是node，那可以使用下面相应的长文本解密方法。其他语言代码逻辑相同。思路就是117bytes的加密，解密使用128bytes位，也就是每128bytes位解密一次，最后拼接在一起。代码及注释如下： 12345678910111213141516171819202122232425/** * 长文本解密 * @param &#123;string&#125; string 加密后的base64编码 * @returns &#123;string&#125; 解密后的原文 * */ JSEncrypt.prototype.decryptLong = function (string) &#123; var k = this.getKey(); var maxLength = 128; try &#123; var string = b64tohex(string); var ct = \"\"; if (string.length &gt; maxLength * 2) &#123; var lt = string.match(/.&#123;1,256&#125;/g); //128位解密。取256位 lt.forEach(function (entry) &#123; var t1 = k.decrypt(entry); ct += t1; &#125;); return ct; &#125; var y = k.decrypt(string); return y; &#125; catch (ex) &#123; return false; &#125; &#125;; 使用方法将上面的两段代码加载JSEncrypt库的后面，使用方法就是将原先加解密调用的方法换为此处的两个方法即可。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://yoursite.com/tags/RSA/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"实现一个Markdown实时转HTML预览","slug":"实现一个Markdown实时转HTML预览","date":"2018-02-01T03:16:07.000Z","updated":"2018-12-17T15:35:22.218Z","comments":true,"path":"2018/02/01/实现一个Markdown实时转HTML预览/","link":"","permalink":"http://yoursite.com/2018/02/01/实现一个Markdown实时转HTML预览/","excerpt":"","text":"需求描述 在后台管理系统写文章的时候，产品希望有个预览模式，左边用markdown语法写，右边能实时预览到最终效果。这样的效果在很多文章类网站都有实践，比如简书。经过分析后，实现的方法就是实时的监听文件的变化，然后转换为HTML，发送给浏览器渲染。 实现思路 1、首先使用fs模块的watch方法监听MD文件的变化。2、当监听到文件变化后，借助marked包提供的mared方法将md内容转换为html。3、将得到的html以及读入的css文件替换到模板，得到最终要渲染的html。4、最后利用BrowserSync模块实现浏览器自动刷新，即每当改变markdown文件，浏览器中会自动刷新显示。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const fs = require('fs');const path = require('path');const marked = require('marked');const browserSync = require('browser-sync');//接收需要转换的文件路径const target = path.join(__dirname, process.argv[2] || 'README.md')//最终生成的html文件的位置const filename = target.replace(path.extname(target), '.html')//获取html文件名const indexpath = path.basename(filename);//通过browser-sync创建一个文件服务器browserSync(&#123; notify: false, server: path.dirname(target),//网站根目录 index: indexpath//默认文档&#125;)//监视文件变化，可以理解为当文件发生变化（需要保存才能触发文件变化)，interval时间间隔后调用回调函数fs.watchFile(target, &#123; interval: 200 &#125;, (cur, prev) =&gt; &#123; // console.log(`current:$&#123;cur.size&#125; previous:$&#123;prev.size&#125;`); //判断文件的最后修改时间是否改变，减少不必要的转换 if (cur.mtime === prev.mtime) &#123; return false; &#125; fs.readFile(target, 'utf8', (err, content) =&gt; &#123; if (err) &#123; throw err; &#125; let html = marked(content); // console.log(html); fs.readFile(path.join(__dirname, 'github.css'), 'utf8', (err, css) =&gt; &#123; html = template.replace('&#123;&#123;&#123;content&#125;&#125;&#125;', html).replace('&#123;&#123;&#123;styles&#125;&#125;&#125;', css); // console.log(html); fs.writeFile(filename, html, (err) =&gt; &#123; if (err) &#123; throw err; &#125; browserSync.reload(indexpath); console.log('updated@' + new Date()); &#125;) &#125;) &#125;)&#125;)const template = `&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Markdown to Html&lt;/title&gt; &lt;style&gt;&#123;&#123;&#123;styles&#125;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='vs'&gt; &#123;&#123;&#123;content&#125;&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;`;","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"学习大厂利用localStorage优化加载","slug":"学习大厂利用localStorage优化加载","date":"2018-01-29T06:48:54.000Z","updated":"2018-12-17T15:35:22.217Z","comments":true,"path":"2018/01/29/学习大厂利用localStorage优化加载/","link":"","permalink":"http://yoursite.com/2018/01/29/学习大厂利用localStorage优化加载/","excerpt":"","text":"利用LocalStorage来对部分请求的数据和结果进行缓存，省去发送http请求所消耗的时间，从而提高网页的响应速度。这类做法在移动端应用已经十分广泛。可以膜拜下鹅、猫、狗三家页面是如何利用LS来进行请求缓存的。 微信 利用LS来对js文件进行缓存。 如下图所示，用浏览器打开一篇微信公众账号文章，打开控制台，发现Network里竟然一个js文件都不需要加载？一脸懵逼！ 切到LS才哗然大悟，原来所有的JS都藏在这里了！ 微信就是利用了这种技巧来缓存关键路径里的js资源，从而大大加快了页面访问速度。当然，实际实现起来，并不像表面看得那样，第一次访问时将js放到LS里，每次进来取出来执行这么简单，最核心的其实是需要设计一套缓存更新机制。首先我们对于缓存的js文件要通过后缀来设置独一无二的版本标识；其次，每次后端需要传一份资源配置文件，前端会根据这个配置文件来和LS中缓存的文件进行版本标识匹配，从而决定是利用LS缓存，还是重新发请求更新资源。例如，微信中的这个配置文件就是通过moon_map来同步输出给前端的，如下图所示： 天猫 利用LS来对关键的XHR异步请求进行缓存。 以天猫超市首页为例： 如下图，查看LS，发现其对首屏中的轮播和10个分类入口的数据进行了缓存。 上面的json内容，格式化后，发现其中包含banner和flowIcons这两个属性，里面的数据分别对应的就是轮播和分类入口的数据。这样就可以大大提升首屏的渲染展示时间。 京东利用LS来对非关键请求进行缓存。以PC版的京东首页为例。京东反向思维，另辟奇径地采用了另一种方式来利用LS。那就是把非关键请求剥离出来存放在LS内。具体来说，对于首屏数据，还是正常加载和展示。但为了非首屏数据的加载和渲染会阻塞和抢占资源，从而影响首屏页面渲染。所以将非首屏资源的HTML/CSS等资源抽出来放在LS内，当页面滚动到可视区域时再去LS中获取数据，插入到dom中。这点很类似于现在的模块懒加载。如下图所示，每个LS里都包含了一个模块所需要的HTML/CSS的资源。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[]},{"title":"js事件防抖动、节流处理","slug":"js事件防抖动、节流处理","date":"2018-01-29T02:58:53.000Z","updated":"2018-12-17T15:35:22.216Z","comments":true,"path":"2018/01/29/js事件防抖动、节流处理/","link":"","permalink":"http://yoursite.com/2018/01/29/js事件防抖动、节流处理/","excerpt":"","text":"问题出发点在开发中针对一些会频繁触发的事件如scroll、resize，如果正常绑定事件处理函数的话，有可能在很短的时间内多次连续触发事件，十分影响性能。 因此针对这类事件要进行防抖动或者节流处理 防抖动它的做法是限制下次函数调用之前必须等待的时间间隔。正确实现 debouncing 的方法是将若干个函数调用合成 一次，并在给定时间过去之后仅被调用一次。 1234567891011121314151617181920212223242526// 将会包装事件的 debounce 函数function debounce(fn, delay) &#123; // 维护一个 timer let timer = null; return function() &#123; // 通过 ‘this’ 和 ‘arguments’ 获取函数的作用域和变量 let context = this; let args = arguments; clearTimeout(timer); timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125;&#125;// 当用户滚动时被调用的函数function foo() &#123; console.log('You are scrolling!');&#125;// 在 debounce 中包装我们的函数，过 2 秒触发一次let elem = document.getElementById('container');elem.addEventListener('scroll', debounce(foo, 2000)); 首先，我们为scroll事件绑定处理函数，这时debounce函数会立即调用，因此给scroll事件绑定的函数实际上是debounce内部返回的函数。 每一次事件被触发，都会清除当前的 timer 然后重新设置超时调用。 这就会导致每一次高频事件都会取消前一次的超时调用，导致事件处理程序不能被触发。 只有当高频事件停止，最后一次事件触发的超时调用才能在delay时间后执行 更进一步，我们不希望非要等到事件停止触发后才执行，我希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。这里增加一个immediate参数来设置是否要立即执行： 123456789101112131415161718192021222324function debouce(func,delay,immediate)&#123; var timer = null; return function()&#123; var context = this; var args = arguments; if(timer) clearTimeout(time); if(immediate)&#123; //根据距离上次触发操作的时间是否到达delay来决定是否要现在执行函数 var doNow = !timer; //每一次都重新设置timer，就是要保证每一次执行的至少delay秒后才可以执行 timer = setTimeout(function()&#123; timer = null; &#125;,delay); //立即执行 if(doNow)&#123; func.apply(context,args); &#125; &#125;else&#123; timer = setTimeout(function()&#123; func.apply(context,args); &#125;,delay); &#125; &#125;&#125; 节流节流是另一种处理类似问题的解决方法。节流函数允许一个函数在规定的时间内只执行一次。 它和防抖动最大的区别就是，节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流阀技术来实现。 主要有两种实现方法： 时间戳 定时器 时间戳实现：123456789101112var throttle = function(func,delay)&#123; var prev = Date.now(); return function()&#123; var context = this; var args = arguments; var now = Date.now(); if(now-prev&gt;=delay)&#123; func.apply(context,args); prev = Date.now(); &#125; &#125;&#125; 当高频事件触发时，第一次应该会立即执行（给事件绑定函数与真正触发事件的间隔如果大于delay的话），而后再怎么频繁触发事件，也都是会每delay秒才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了。 定时器实现：当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行；直到delay秒后，定时器执行执行函数，清空定时器，这样就可以设置下个定时器。 1234567891011121314var throttle = fucntion(func,delay)&#123; var timer = null; return funtion()&#123; var context = this; var args = arguments; if(!timer)&#123; timer = setTimeout(function()&#123; func.apply(context,args); timer = null; &#125;,delay); &#125; &#125;&#125; 当第一次触发事件时，肯定不会立即执行函数，而是在delay秒后才执行。之后连续不断触发事件，也会每delay秒执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。 可以综合使用时间戳与定时器，完成一个事件触发时立即执行，触发完毕还能执行一次的节流函数： 12345678910111213141516171819var throttle = function(func,delay)&#123; var timer = null; var startTime = Date.now(); return function()&#123; var curTime = Date.now(); var remaining = delay-(curTime-startTime); var context = this; var args = arguments; clearTimeout(timer); if(remaining&lt;=0)&#123; func.apply(context,args); startTime = Date.now(); &#125;else&#123; timer = setTimeout(func,remaining); &#125; &#125;&#125; 需要在每个delay时间中一定会执行一次函数，因此在节流函数内部使用开始时间、当前时间与delay来计算remaining，当remaining&lt;=0时表示该执行函数了，如果还没到时间的话就设定在remaining时间后再触发。当然在remaining这段时间中如果又一次发生事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。 总结防止一个事件频繁触发回调函数的方式： 防抖动：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 节流：使得一定时间内只触发一次函数。它和防抖动最大的区别就是，节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而防抖动只是在最后一次事件后才触发一次函数。 原理是通过判断是否到达一定时间来触发函数，若没到规定时间则使用计时器延后，而下一次事件则会重新设定计时器。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"性能","slug":"性能","permalink":"http://yoursite.com/tags/性能/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"git工程实战","slug":"git工程实战","date":"2018-01-18T02:17:55.000Z","updated":"2018-12-17T15:35:22.216Z","comments":true,"path":"2018/01/18/git工程实战/","link":"","permalink":"http://yoursite.com/2018/01/18/git工程实战/","excerpt":"","text":"本笔记记录git在项目开发中完整的实践过程，方便以后忘记时查看 首先将要开发的项目主分支clone到本地 1git clone http://gitlab.khweb.com/ths-khweb/khh5-basic.git 将远程项目clone到本地后，我们查看到的是主分支，如果我们要对其中一个远程分支进行开发话，首先要看见远程所有分支 1git branch -a 然后切换到远程目标分支，并创建本地分支 1git checkout -b khh5_taipingyang origin/khh5_taipingyang 以后所有的开发就在本地khh5_taipingyang分支中进行。当要将本地分支推送远程时，我们为了不影响其他开发人员也有可能在开发这个远程分支，所以我们要推送到自己新建的远程分支khh5_taipingyang_zly 123git add .git commit -m \"test\"git push origin/khh5_taipingyang_zly 这样我们就新建了一个自己的分支。当后面开发完成后对代码review后可以将远程自己的分支与原分支进行合并,并删除自己的分支 12git push origin/khh5_taipingyanggit push origin :khh5_taipingyang_zly 如果你需要在本地对两个分支进行开发，就要使用git的分支应用。git下分支的应用是很方便的一个功能，但是有一个问题，如果我在分支A有工作尚未完成，想要跳到分支B，如果不注意，可能搞乱你的工作。 首先说，如果你的分支分支A工作区和缓存区是干净的（即你在A分支commit之后再没做任何更改），你随便往别的分支跳都不会有影响的。但是如果你在A分支下有未完成的工作，即你用git status看显示有没有add或者commit的内容，你往B分支checkout的时候，会把你在A分支下的工作带过去，如图： 在命令$git checkout B之后显示的A A1 和A A2意思即为提醒使用者，有未提交的工作也一起跳转到分支B上啦（前面的大写A意味着A1，A2文件是新建且已经git add的文件；如果是大写M则意味着A1，A2文件为内容有更改的原有文件；D则意味着是删除了A1，A2文件）。这个时候你如果在B分支上进行其他工作而不编辑A1，A2文件，目前来说是没问题的。然而，一旦你在B分支上完成了某项工作，运行了commit命令，A1，A2文件之前的更改也会在A分支上进行提交，而git的规矩是，在那个分支上进行的提交，就算哪个分支上的工作。 也就是说，一旦你把A分支上尚未完成的工作带到了B分支上并在B分支上顺利提交，那么你本来希望是在A分支上进行的工作，则会被提交到本地库中B分支上，该部分工作在A分支下用git log命令查看不到但是在B分支下则可以查看到。这在实际的工作中会导致你的两个分支乱掉或者出现提交冲突。不是不能补救，但是会很麻烦，所以要尽量避免。 那么怎么避免呢？事实上，在比较旧的版本的git下，你在分支A下有未完成的工作的情形下，是无法跳转到分支B下的，这就很好的避免了后续的尴尬情况，不过目前版本的git是允许你带着未完成工作进行跳转的，所以你可以通过以下手段来避免这种情况下搞乱你的工作： 1.跳转分支之前git status一下查看是不是有没有add和commit的工作，如果有，可以的话，就都提交掉。（事实上尚未add的工作带到了新分支下如果不继续对该文件进行处理，带过去也是没有影响的，大不了跳回来再带回来嘛，反正木有add过的内容在新分支下commit也不会把这部分工作提交。） 2.如果确实有尚未add和commit的工作，但是并未完成不方便进行提交，可以利用git stash进行现场保留，然后跳转。（git stash的用法也是一块比较重要的内容，这里暂不详细介绍了，可以直接百度其用法~） 3.如果1.2你都没有做，很不小心地带着未commit的工作跳转到了另一分支下，跳转之后的提示可以让你意识到你把先前分支的工作带过来了，不做任何修改直接再跳回去就好（就又带回去了），然后进行1或2步中所说。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"psd自动标注软件PxCook","slug":"psd自动标注软件PxCook","date":"2018-01-17T08:42:36.000Z","updated":"2018-12-17T15:35:22.216Z","comments":true,"path":"2018/01/17/psd自动标注软件PxCook/","link":"","permalink":"http://yoursite.com/2018/01/17/psd自动标注软件PxCook/","excerpt":"","text":"PxCook是什么?一个从设计到代码, 让团队高效协作高效易用的自动标注工具, 生成前端代码, 设计研发协作利器 PxCook有哪些功能？ 自动手动随意切, 既精准又快捷只需点击拖拽, 即可轻松获得间距尺寸, 字体, 阴影圆角等所有信息。PNG, JPG也能手动测量。支持标注单位：PX , PT , DP/SP , REM。 提高前端开发效率直接生成可执行样式代码热门语言全部支持：CSS, XML, Objective-C, Swift, ReactNative持续更新中⋯⋯ 安装步骤 打开PxCook官网PxCook 首先安装PxCook之前一定要先安装Adobe AIR (需要翻墙) 安装完两个软件后根据软件提示进行操作即可 是不是很方便了，这个工具可以大大减少前端人员的开发时间，让你不为开发样式而耗费心思。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"切图","slug":"切图","permalink":"http://yoursite.com/tags/切图/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"CORS自定义头部问题","slug":"2018-01-02-CORS自定义头部问题","date":"2018-01-02T12:29:41.000Z","updated":"2018-12-17T15:35:22.215Z","comments":true,"path":"2018/01/02/2018-01-02-CORS自定义头部问题/","link":"","permalink":"http://yoursite.com/2018/01/02/2018-01-02-CORS自定义头部问题/","excerpt":"","text":"一、什么是CORSCORS（Cross-Origin Resource Sharing 跨源资源共享），当一个请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。二、问题描述本人最近在写做公司的项目的时候，遇到后端需要我将登陆接口返回的token写在后面每次接口请求的头部中：但是这样会出现如下的问题二、原因点：后来查了一下，当浏览器检查到有跨域的问题，会对访问的接口做一个判断，如果是简单的接口，则直接访问，如果是复杂的接口，则需要先发送一个option请求，但是后端的路由里面没有定义该接口的option请求 ，因此报了一个404错误三、解决方法 具体代码如下： 12345678910//node koaapp.use(async (ctx,next)=&gt;&#123; ctx.set(\"Access-Control-Allow-Headers: token\"); //设定的自定义头部 ctx.set('Access-Control-Allow-Origin','*'); await next();&#125;)router.options('*',async (ctx,next) =&gt; &#123; await next(); &#125;); 12345678910111213//phpnamespace app\\api\\behavior;class CORS&#123; public function appInit(&amp;amp;$params) &#123; header('Access-Control-Allow-Origin: *'); header(\"Access-Control-Allow-Headers: token,Origin, X-Requested-With, Content-Type, Accept\"); if(request()-&amp;gt;isOptions())&#123; exit(); &#125; &#125;&#125; 四、总结 在浏览器判断有跨域问题并且是一个非简单请求的时候，首先会发起一个options请求，在options请求被服务端处理并返回200后，才开始正式访问数据。并成功请求到数据。","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"CORS","slug":"CORS","permalink":"http://yoursite.com/tags/CORS/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"react和redux教程完整总结","slug":"2017-11-04-react和redux教程完整总结","date":"2017-11-04T14:12:21.000Z","updated":"2018-12-17T15:35:22.208Z","comments":true,"path":"2017/11/04/2017-11-04-react和redux教程完整总结/","link":"","permalink":"http://yoursite.com/2017/11/04/2017-11-04-react和redux教程完整总结/","excerpt":"","text":"本笔记只供个人参考做React需要会什么？react的功能其实很单一，主要负责渲染的功能，想要做好一个项目，往往需要其他库和工具的配合，比如用redux来管理数据，react-router管理路由，react已经全面拥抱es6，所以es6也得掌握，webpack就算是不会配置也要会用，要想提高性能，需要按需加载，immutable.js也得用上。。。 React 是什么用脚本进行DOM操作的代价很昂贵。有个贴切的比喻，把DOM和JavaScript各自想象为一个岛屿，它们之间用收费桥梁连接，js每次访问DOM，都要途径这座桥，并交纳“过桥费”,访问DOM的次数越多，费用也就越高。 因此，推荐的做法是尽量减少过桥的次数，努力待在ECMAScript岛上。因为这个原因react的虚拟dom就显得难能可贵了，它创造了虚拟dom并且将它们储存起来，每当状态发生变化的时候就会创造新的虚拟节点和以前的进行对比，让变化的部分进行渲染。整个过程没有对dom进行获取和操作，只有一个渲染的过程，所以react说是一个ui框架。 React的组件化react的一个组件很明显的由dom视图和state数据组成，两个部分泾渭分明。state是数据中心，它的状态决定着视图的状态。这时候发现似乎和我们一直推崇的MVC开发模式有点区别，没了Controller控制器，那用户交互怎么处理，数据变化谁来管理？然而这并不是react所要关心的事情，它只负责ui的渲染。与其他框架监听数据动态改变dom不同，react采用setState来控制视图的更新。setState会自动调用render函数，触发视图的重新渲染，如果仅仅只是state数据的变化而没有调用setState，并不会触发更新。 组件就是拥有独立功能的视图模块，许多小的组件组成一个大的组件，整个页面就是由一个个组件组合而成。它的好处是利于重复利用和维护。 React的 Diff算法react的diff算法用在什么地方呢？当组件更新的时候，react会创建一个新的虚拟dom树并且会和之前储存的dom树进行比较，这个比较多过程就用到了diff算法，所以组件初始化的时候是用不到的。react提出了一种假设，相同的节点具有类似的结构，而不同的节点具有不同的结构。在这种假设之上进行逐层的比较，如果发现对应的节点是不同的，那就直接删除旧的节点以及它所包含的所有子节点然后替换成新的节点。如果是相同的节点，则只进行属性的更改。 对于列表的diff算法稍有不同，因为列表通常具有相同的结构，在对列表节点进行删除，插入，排序的时候，单个节点的整体操作远比一个个对比一个个替换要好得多，所以在创建列表的时候需要设置key值，这样react才能分清谁是谁。当然不写key值也可以，但这样通常会报出警告，通知我们加上key值以提高react的性能。 React组件是怎么来的组件的创造方法为React.createClass() ——创造一个类，react系统内部设计了一套类系统，利用它来创造react组件。但这并不是必须的，我们还可以用es6的class类来创造组件,这也是Facebook官方推荐的写法。 12345678class Main extends React.Component&#123; constructor(props)&#123; super(props); this.state= &#123; state1: '' &#125; &#125;&#125; 这两种写法实现的功能一样但是原理却是不同，es6的class类可以看作是构造函数的一个语法糖，可以把它当成构造函数来看，extends实现了类之间的继承 —— 定义一个类Main 继承React.Component所有的属性和方法，组件的生命周期函数就是从这来的。constructor是构造器，在实例化对象时调用，super调用了父类的constructor创造了父类的实例对象this，然后用子类的构造函数进行修改。这和es5的原型继承是不同的，原型继承是先创造一个实例化对象this，然后再继承父级的原型方法。了解了这些之后我们在看组件的时候就清楚很多。 当我们使用组件&lt; Main /&gt;时，其实是对Main类的实例化——new Main，只不过react对这个过程进行了封装，让它看起来更像是一个标签。 有三点值得注意：1、定义类名字的首字母必须大写 2、因为class变成了关键字，类选择器需要用className来代替。 3、类和模块内部默认使用严格模式，所以不需要用use strict指定运行模式。 组件的生命周期 组件在初始化时会触发5个钩子函数： 1、getDefaultProps() 设置默认的props，也可以用dufaultProps设置组件的默认属性。 2、getInitialState() 在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。 3、componentWillMount() 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。 4、 render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。 5、componentDidMount() 组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。 在更新时也会触发5个钩子函数： 6、componentWillReceivePorps(nextProps) 组件初始化时不调用，组件接受新的props时调用。 7、shouldComponentUpdate(nextProps, nextState) react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。 8、componentWillUpdate(nextProps, nextState) 组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state 9、render() 不多说 10、componentDidUpdate() 组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。 还有一个卸载钩子函数 11、componentWillUnmount() 组件将要卸载时调用，一些事件监听和定时器需要在此时清除。 以上可以看出来react总共有10个周期函数（render重复一次），这个10个函数可以满足我们所有对组件操作的需求，利用的好可以提高开发效率和组件性能。 React-Router路由Router就是React的一个组件，它并不会被渲染，只是一个创建内部路由规则的配置对象，根据匹配的路由地址展现相应的组件。Route则对路由地址和组件进行绑定，Route具有嵌套功能，表示路由地址的包涵关系，这和组件之间的嵌套并没有直接联系。Route可以向绑定的组件传递7个属性：children，history，location，params，route，routeParams，routes，每个属性都包涵路由的相关的信息。比较常用的有children（以路由的包涵关系为区分的组件），location（包括地址，参数，地址切换方式，key值，hash值）。react-router提供Link标签，这只是对a标签的封装，值得注意的是，点击链接进行的跳转并不是默认的方式，react-router阻止了a标签的默认行为并用pushState进行hash值的转变。切换页面的过程是在点击Link标签或者后退前进按钮时，会先发生url地址的转变，Router监听到地址的改变根据Route的path属性匹配到对应的组件，将state值改成对应的组件并调用setState触发render函数重新渲染dom。 当页面比较多时，项目就会变得越来越大，尤其对于单页面应用来说，初次渲染的速度就会很慢，这时候就需要按需加载，只有切换到页面的时候才去加载对应的js文件。react配合webpack进行按需加载的方法很简单，Route的component改为getComponent，组件用require.ensure的方式获取，并在webpack中配置chunkFilename。 1234567891011121314151617181920212223const chooseProducts = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../Component/chooseProducts').default) &#125;,'chooseProducts')&#125;const helpCenter = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../Component/helpCenter').default) &#125;,'helpCenter')&#125;const RouteConfig = ( &lt;Router history=&#123;history&#125;&gt; &lt;Route path=\"/\" component=&#123;Roots&#125;&gt; &lt;IndexRoute component=&#123;index&#125; /&gt;//首页 &lt;Route path=\"index\" component=&#123;index&#125; /&gt; &lt;Route path=\"helpCenter\" getComponent=&#123;helpCenter&#125; /&gt;//帮助中心 &lt;Redirect from='*' to='/' /&gt; &lt;/Route&gt; &lt;/Router&gt;); 组件之间的通信react推崇的是单向数据流，自上而下进行数据的传递，但是由下而上或者不在一条数据流上的组件之间的通信就会变的复杂。解决通信问题的方法很多，如果只是父子级关系，父级可以将一个回调函数当作属性传递给子级，子级可以直接调用函数从而和父级通信。 组件层级嵌套到比较深，可以使用上下文getChildContext来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过this.context直接访问。 兄弟关系的组件之间无法直接通信，它们只能利用同一层的上级作为中转站。而如果兄弟组件都是最高层的组件，为了能够让它们进行通信，必须在它们外层再套一层组件，这个外层的组件起着保存数据，传递信息的作用，这其实就是redux所做的事情。 组件之间的信息还可以通过全局事件来传递。不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。 Redux首先，redux并不是必须的，它的作用相当于在顶层组件之上又加了一个组件，作用是进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信。如果组件之间的交流不多，逻辑不复杂，只是单纯的进行视图的渲染，这时候用回调，context就行，没必要用redux，用了反而影响开发速度。但是如果组件交流特别频繁，逻辑很复杂，那redux的优势就特别明显了。我第一次做react项目的时候并没有用redux，所有的逻辑都是在组件内部实现，当时为了实现一个逻辑比较复杂的购物车，洋洋洒洒居然写了800多行代码，回头一看我自己都不知道写的是啥，画面太感人。 先简单说一下redux和react是怎么配合的。react-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。 流程是这个样子的： 值得注意的是connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起。 接下来具体分析一下，redux以及react-redux到底是怎么实现的。先上一张图 明显比第一张要复杂，其实两张图说的是同一件事。从上而下慢慢分析： 先说说redux：redux主要由三部分组成：store，reducer，action。store是一个对象，它有四个主要的方法： 1、dispatch: 用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。 2、subscribe： 监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。let unsubscribe = store.subscribe(() =&gt; {console.log(‘state发生了变化’)}) 3、getState： 获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。 4、replaceReducer: 替换reducer，改变state修改的逻辑。 store可以通过createStore()方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。 action: action是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreactor进行创造。dispatch就是把action对象发送出去。 reducer: reducer是一个函数，它接受一个state和一个action，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。 像这个样子：12345const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;) combineReducers: 其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。 接下来分析一下整体的流程，首先调用store.dispatch将action作为参数传入，同时用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。 redux的state和react的state两者完全没有关系，除了名字一样。 上面分析了redux的主要功能，那么react-redux到底做了什么？ React-Redux如果只使用redux，那么流程是这样的： component –&gt; dispatch(action) –&gt; reducer –&gt; subscribe –&gt; getState –&gt; component 用了react-redux之后流程是这样的： component –&gt; actionCreator(data) –&gt; reducer –&gt; component store的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。 Provider是一个组件，它接受store作为props，然后通过context往下传，这样react中任何组件都可以通过context获取store。也就意味着我们可以在任何一个组件里利用dispatch(action)来触发reducer改变state，并用subscribe监听state的变化，然后用getState获取变化后的值。但是并不推荐这样做，它会让数据流变的混乱，过度的耦合也会影响组件的复用，维护起来也更麻烦。 connect –connect(mapStateToProps, mapDispatchToProps, mergeProps, options) 是一个函数，它接受四个参数并且再返回一个函数–wrapWithConnect，wrapWithConnect接受一个组件作为参数wrapWithConnect(component)，它内部定义一个新组件Connect(容器组件)并将传入的组件(ui组件)作为Connect的子组件然后return出去。 所以它的完整写法是这样的：connect(mapStateToProps, mapDispatchToProps, mergeProps, options)(component) mapStateToProps(state, [ownProps])： mapStateToProps 接受两个参数，store的state和自定义的props，并返回一个新的对象，这个对象会作为props的一部分传入ui组件。我们可以根据组件所需要的数据自定义返回一个对象。ownProps的变化也会触发mapStateToProps 123function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;;&#125; mapDispatchToProps(dispatch, [ownProps])： mapDispatchToProps如果是对象，那么会和store绑定作为props的一部分传入ui组件。如果是个函数，它接受两个参数，bindActionCreators会将action和dispatch绑定并返回一个对象，这个对象会和ownProps一起作为props的一部分传入ui组件。所以不论mapDispatchToProps是对象还是函数，它最终都会返回一个对象，如果是函数，这个对象的key值是可以自定义的 123456function mapDispatchToProps(dispatch) &#123; return &#123; todoActions: bindActionCreators(todoActionCreators, dispatch), counterActions: bindActionCreators(counterActionCreators, dispatch) &#125;;&#125; mapDispatchToProps返回的对象其属性其实就是一个个actionCreator，因为已经和dispatch绑定，所以当调用actionCreator时会立即发送action，而不用手动dispatch。ownProps的变化也会触发mapDispatchToProps。 mergeProps(stateProps, dispatchProps, ownProps)： 将mapStateToProps() 与 mapDispatchToProps()返回的对象和组件自身的props合并成新的props并传入组件。默认返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。 options： pure = true 表示Connect容器组件将在shouldComponentUpdate中对store的state和ownProps进行浅对比，判断是否发生变化，优化性能。为false则不对比。 其实connect函数并没有做什么，大部分的逻辑都是在它返回的wrapWithConnect函数内实现的，确切的说是在wrapWithConnect内定义的Connect组件里实现的。 下面是一个完整的 react –&gt; redux –&gt; react 流程：一、Provider组件接受redux的store作为props，然后通过context往下传。 二、connect函数在初始化的时候会将mapDispatchToProps对象绑定到store，如果mapDispatchToProps是函数则在Connect组件获得store后，根据传入的store.dispatch和action通过bindActionCreators进行绑定，再将返回的对象绑定到store，connect函数会返回一个wrapWithConnect函数，同时wrapWithConnect会被调用且传入一个ui组件，wrapWithConnect内部使用class Connect extends Component定义了一个Connect组件，传入的ui组件就是Connect的子组件，然后Connect组件会通过context获得store，并通过store.getState获得完整的state对象，将state传入mapStateToProps返回stateProps对象、mapDispatchToProps对象或mapDispatchToProps函数会返回一个dispatchProps对象，stateProps、dispatchProps以及Connect组件的props三者通过Object.assign()，或者mergeProps合并为props传入ui组件。然后在ComponentDidMount中调用store.subscribe，注册了一个回调函数handleChange监听state的变化。 三、此时ui组件就可以在props中找到actionCreator，当我们调用actionCreator时会自动调用dispatch，在dispatch中会调用getState获取整个state，同时注册一个listener监听state的变化，store将获得的state和action传给combineReducers，combineReducers会将state依据state的key值分别传给子reducer，并将action传给全部子reducer，reducer会被依次执行进行action.type的判断，如果有则返回一个新的state，如果没有则返回默认。combineReducers再次将子reducer返回的单个state进行合并成一个新的完整的state。此时state发生了变化。dispatch在state返回新的值之后会调用所有注册的listener函数其中包括handleChange函数，handleChange函数内部首先调用getState获取新的state值并对新旧两个state进行浅对比，如果相同直接return，如果不同则调用mapStateToProps获取stateProps并将新旧两个stateProps进行浅对比，如果相同，直接return结束，不进行后续操作。如果不相同则调用this.setState()触发Connect组件的更新，传入ui组件，触发ui组件的更新，此时ui组件获得新的props，react –&gt; redux –&gt; react 的一次流程结束。 上面的有点复杂，简化版的流程是： 一、Provider组件接受redux的store作为props，然后通过context往下传。 二、connect函数收到Provider传出的store，然后接受三个参数mapStateToProps，mapDispatchToProps和组件，并将state和actionCreator以props传入组件，这时组件就可以调用actionCreator函数来触发reducer函数返回新的state，connect监听到state变化调用setState更新组件并将新的state传入组件。 connect可以写的非常简洁，mapStateToProps，mapDispatchToProps只不过是传入的回调函数，connect函数在必要的时候会调用它们，名字不是固定的，甚至可以不写名字。 简化版本：1connect(state =&gt; state, action)(Component); 项目搭建上面说了react，react-router和redux的知识点。但是怎么样将它们整合起来，搭建一个完整的项目。 1、先引用 react.js，redux，react-router 等基本文件，建议用npm安装，直接在文件中引用。 2、从 react.js，redux，react-router 中引入所需要的对象和方法。12345import React, &#123;Component, PropTypes&#125; from 'react';import ReactDOM, &#123;render&#125; from 'react-dom';import &#123;Provider, connect&#125; from 'react-redux';import &#123;createStore, combineReducers, applyMiddleware&#125; from 'redux';import &#123; Router, Route, Redirect, IndexRoute, browserHistory, hashHistory &#125; from 'react-router'; 3、根据需求创建顶层ui组件，每个顶层ui组件对应一个页面。 4、创建actionCreators和reducers，并用combineReducers将所有的reducer合并成一个大的reduer。利用createStore创建store并引入combineReducers和applyMiddleware。 5、利用connect将actionCreator，reuder和顶层的ui组件进行关联并返回一个新的组件。 6、利用connect返回的新的组件配合react-router进行路由的部署，返回一个路由组件Router。 7、将Router放入最顶层组件Provider，引入store作为Provider的属性。 8、调用render渲染Provider组件且放入页面的标签中。 可以看到顶层的ui组件其实被套了四层组件，Provider，Router，Route，Connect，这四个组件并不会在视图上改变react，它们只是功能性的。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"开发问题总结","slug":"2016-08-03-开发问题总结","date":"2017-11-03T12:45:41.000Z","updated":"2018-12-17T15:35:22.203Z","comments":true,"path":"2017/11/03/2016-08-03-开发问题总结/","link":"","permalink":"http://yoursite.com/2017/11/03/2016-08-03-开发问题总结/","excerpt":"","text":"在移动端开发弹窗的时候，会出现弹窗出来后整个页面还是可以移动的情况。处理方法有以下几种： 1$('body,html').css('overflow','hidden').scrollTop(0); 这样就可以禁止页面滚动，同时不管在哪点击弹窗都会返回顶部。这里scrollTop可能会失效，失效的原因就是body和html没有高度。 123body,html &#123; height: 100%; &#125; 这样可以让弹窗不管在哪里点击都显示正中央，但是在ios上有点bug，就是会让最低部的元素的margin-bottom失效。 ios中click使用on添加事件委托失败。如下代码：12345$(document).on('click',function(event) &#123; if (event.target.className == 'kk' || event.target.className == 'jj') &#123; alert('失败'); &#125;&#125;); 上述代码在安卓设备可以正常返回失败，但是在ios中没有效果，解决方法是将click事件改为touchstart即可。 用对象语法替代switch（javascript规范中写道尽量不要使用switch）编写含有switch的代码的时候很容易忘记在每个判断后面添加break，造成代码虽然没有报错但是无法正常运行的情况。同时switch语法的性能也不是很好。这里推荐使用对象遍历替代switch。无码言diao： 123456789101112131415161718192021222324252627282930313233343536 //switch语法 $('.on').on('click',function(event) &#123; switch (event.target.className) &#123; case 'uploadCard': alert('上传身份证'); break; case 'videoRes': alert('视频'); break; case 'bankCard': alert('银行卡'); break; &#125; &#125;); //对象语法 $('.on').on('click',function(event) &#123; var alertObj = &#123; 'uploadIdCard': '上传身份证', 'videoRes': '视频', 'bankCard': '银行卡' &#125;; for (var key in alertObj) &#123; if (event.target.className == key) &#123; alert(alertObj[key]); &#125; &#125; &#125;); ``` 两段代码比较很容看出switch代码结构不美观，如果数据很多的话更是很糟。而对象语法就没有这个问题，当数据很多完全可以用json格式代替。 * ### iPhone6plus ios8系统下box-shadow失效 如下代码在ip6+，ios8系统是无法显示shadow或者显示不正常的： ```css box-shadow: 0 0 5px #eee; 而在其他机型是正常的。解决方式就是加上如下代码 12box-shadow: 0 0 5px #eee;border-radius: 1px; 移动端禁止弹窗下面的body滑动通常实现弹窗的方法就是使用fixed定位，但是这样在移动端就会出现弹窗下面的body还可以滚动的效果。要想是body不滚动，就要摒弃fixed定位改为absolute定位。具体做法如下： 首先给html和body添加height:100%;overflow:hidden; 给页面container添加height:100%;overflow-x:hidden;overflow-y:auto; 然后给弹窗container添加height:100%;position:absolult，弹窗mask添加height:100%;position:absolute，弹窗contain添加position:relative。 实现原理就是将整个弹窗的container（包括弹窗和mask）绝对定位在屏幕中，然后弹窗使用相对定位。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"问题总结","slug":"问题总结","permalink":"http://yoursite.com/tags/问题总结/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"前端安全问题","slug":"2017-11-1-前端安全问题","date":"2017-11-01T05:19:22.000Z","updated":"2018-12-17T15:35:22.208Z","comments":true,"path":"2017/11/01/2017-11-1-前端安全问题/","link":"","permalink":"http://yoursite.com/2017/11/01/2017-11-1-前端安全问题/","excerpt":"","text":"XSS（跨站脚本注入）此类安全问题主要是就是在黑客在使用表单时将自己的脚步script注入我们的网站中，解决的办法就是在拿到表单数据的时候进行转义。 CSRF（跨站请求伪造）此类安全问题就是黑客在自己的网站中请求我们的服务器，解决办法就是利用验证码，这样每次session可以区分是不是我们的网站进行的请求。或者在每次请求的时候加上服务端下发的token值，每次请求服务端进行验证是不是刚才下发的token值。 网络劫持攻击此类安全问题比如当用户连接WiFi的时候，而这个WiFi是黑客的，这样黑客就可以拦截到用户的数据。解决的方法就是使用https进行请求，或者网站对用户的数据进行非对称加密。 控制台注入代码此类安全问题很少见，就是黑客引导不懂代码的用户在控制台执行一段黑客事先写好的脚步。解决方法就是想天猫那样在控制台打印警告信息，告诉用户控制台是开发人员使用的，不要在这里粘贴执行代码，防止信息丢失。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"移动端网页绝对自适应","slug":"2017-10-12-移动端网页绝对自适应","date":"2017-10-12T05:29:22.000Z","updated":"2018-12-17T15:35:22.207Z","comments":true,"path":"2017/10/12/2017-10-12-移动端网页绝对自适应/","link":"","permalink":"http://yoursite.com/2017/10/12/2017-10-12-移动端网页绝对自适应/","excerpt":"","text":"REM1234567891011121314151617(function (doc, win) &#123; var $body = doc.querySelector('body'); var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; clientWidth = clientWidth&gt;750?750:clientWidth;//防止被放大保证宽屏效果 //以宽750px为例子，并扩大100倍，尽可能的保证精度 docEl.style.fontSize = 100 * (clientWidth / 750) + 'px'; //缩放之后再显示页面，防止缩放过程被观察到，影响体验 $body.style.visibility = 'visible'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); meta inital-scale1234567891011121314(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in win ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; clientWidth = clientWidth&gt;750?750:clientWidth;//防止被放大保证宽屏效果 doc.querySelector('meta[name=viewport]').setAttribute('content','width=750, initial-scale='+clientWidth/750+', maximum-scale=1.0, user-scalable=0'); doc.querySelector('body').setAttribute('style','visibility:visible;'); &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt,recalc,false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); transform scale123456789101112131415161718192021(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; var $bodyContent = doc.querySelector('.body-content'); var $body = doc.querySelector('body'); var percent = clientWidth/750; percent = percent&gt;1?1:percent;//防止被放大保证宽屏效果 var othersHeight = $body.clientHeight-$bodyContent.clientHeight;//计算其它元素的高度 $bodyContent.setAttribute('style','width:750px;transform:scale('+percent+');transform-origin:0 0;-webkit-transform:scale('+percent+');-webkit-transform-origin:0 0;margin:auto;'); var lastStyle = $bodyContent.getAttribute('style'); var articleHeight = $bodyContent.clientHeight*percent; $bodyContent.style.height = articleHeight+'px'; $body.setAttribute('style','visibility:visible;height:'+(articleHeight+othersHeight)+'px;'); &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt,recalc,false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window);","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"页面交互","slug":"页面交互","permalink":"http://yoursite.com/tags/页面交互/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"判断滚动条滚到页面底部并执行事件","slug":"2017-10-09-判断滚动条滚到页面底部并执行事件","date":"2017-10-09T04:21:41.000Z","updated":"2018-12-17T15:35:22.207Z","comments":true,"path":"2017/10/09/2017-10-09-判断滚动条滚到页面底部并执行事件/","link":"","permalink":"http://yoursite.com/2017/10/09/2017-10-09-判断滚动条滚到页面底部并执行事件/","excerpt":"","text":"首先理解三个dom元素，分别是：clientHeight、offsetHeight、scrollTop。 clientHeight：这个元素的高度，占用整个空间的高度，所以，如果一个div有滚动条，那个这个高度则是不包括滚动条没显示出来的下面部分的内容。而只是单纯的DIV的高度。 offsetHeight：是指元素内容的高度。依照上面的，那这个高度呢就是DIV内部的高度，包括可见部分及以滚动条下面的不可见部分。 scrollTop：这个是什么呢？他可以理解为滚动条可以滚动的长度。 举例，如果一个DIV高度是400px（即clientHeight为400），而里面的内容是一个很长的列表，内容的高度是1000px（即offsetHeight为1000）。那么，可见部分我们看到400px，1000px的内容中还有600px不可见。而这不可见的部分呢，正是我们通过拉动滚动条才能把这一部分显示出来。你如果滚动条不拉动，此时scrollTop为0，如果你把滚动条拉到底，显示出列表最下面的部分，此时，scrollTop为600。 所以scrollTop的取值区间为[0, 600]。 所以这个600可以理解为滚动条可以滚动的长度。 理解完上面的这个概念之后。要判断是否滚动到底部就很好做了。 首先，我们拉动滚动条，从最上面拉到最下面，变化的是scrollTop的值，而这个值是有一个区间的。这个区间是：[0, (offsetHeight - clientHeight)]。即，滚动条拉动的整个过程的变化在 0 到 (offsetHeight – clientHeight) 范围之内。 1、判断滚动条滚动到最底端：scrollTop == (offsetHeight – clientHeight) 2、在滚动条距离底端50px以内：(offsetHeight – clientHeight) – scrollTop &lt;= 50 3、在滚动条距离底端5%以内：scrollTop / (offsetHeight – clientHeight) &gt;= 0.95 如上。 如果要实现拉到底部自动加载内容。只要注册个滚动条事件：123456789101112scrollBottomTest =function()&#123; $(\"#contain\").scroll(function()&#123; var $this =$(this), viewH =$(this).height(),//可见高度 contentH =$(this).get(0).scrollHeight,//内容高度 scrollTop =$(this).scrollTop();//滚动高度 //if(contentH - viewH - scrollTop &lt;= 100) &#123; //到达底部100px时,加载新内容 if(scrollTop/(contentH -viewH)&gt;=0.95)&#123; //到达底部100px时,加载新内容 // 这里加载数据.. &#125; &#125;); &#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"页面交互","slug":"页面交互","permalink":"http://yoursite.com/tags/页面交互/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"scrollIntoView与scrollIntoViewIfNeeded的使用","slug":"2017-10-04-scrollIntoView 与 scrollIntoViewIfNeeded的使用","date":"2017-10-04T00:32:41.000Z","updated":"2018-12-17T15:35:22.207Z","comments":true,"path":"2017/10/04/2017-10-04-scrollIntoView 与 scrollIntoViewIfNeeded的使用/","link":"","permalink":"http://yoursite.com/2017/10/04/2017-10-04-scrollIntoView 与 scrollIntoViewIfNeeded的使用/","excerpt":"","text":"在日常开发中经常遇到需将某个元素放在视窗之内，让用户一直可见，但是移动端的软键盘会挡住元素。此前一般都是更改scroll位置和更改页面布局来解决此问题，这样处理起来颇为麻烦。但是通过Element.scrollIntoView()和Element.scrollIntoViewIfNeeded()可以方便的实现这个需求。scrollIntoView,此API基本所有浏览器都是支持的。scrollIntoViewIfNeeded，此APIIE和foxfire不支持，所以PC端不能使用，但是移动端是没有问题的。 scrollIntoView先看demo 同时scrollIntoView可以接受一个两种类型的参数，分别是Boolean和Object。先说Boolean型参数，顾名思义，参数可以使true和false。如果为true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。若为false，元素的底端将和其所在滚动区的可视区域的底端对齐。demo:Object型参数，这个对象有两个选项，也就是对象里面的key。block与之前的Boolean型参数一致，不过值不再是true和false，是更语义化的start和end。scrollIntoViewIfNeeded两者主要区别有两个。首先是scrollIntoViewIfNeeded是比较懒散的，如果元素在可视区域，那么调用它的时候，页面是不会发生滚动的。其次是scrollIntoViewIfNeeded只有Boolean型参数。scrollIntoViewIfNeeded可以接受一个Boolean型参数，和scrollIntoView不同，true为默认值，但不是滚动到顶部，而是让元素在可视区域中居中对齐；false时元素可能顶部或底部对齐，视乎元素靠哪边更近。demo:","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"页面交互","slug":"页面交互","permalink":"http://yoursite.com/tags/页面交互/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Jquery或zepto事件委托在ios无效","slug":"2017-09-27-Jquery或zepto事件委托在ios无效","date":"2017-09-21T05:19:22.000Z","updated":"2018-12-17T15:35:22.207Z","comments":true,"path":"2017/09/21/2017-09-27-Jquery或zepto事件委托在ios无效/","link":"","permalink":"http://yoursite.com/2017/09/21/2017-09-27-Jquery或zepto事件委托在ios无效/","excerpt":"","text":"如果要给动态添加的dom绑定点击事件，就要将事件委托到document或绑定元素的父级元素上，具体代码如下：123$(documnent).on('click','.item',function(e) &#123; &#125;) dom中绑定事件的元素结构为&lt;div class=&quot;item&quot;&gt;按钮&lt;/div&gt;此种方式在web和安卓测试都是正常，但是在ios设备会失效，原因就是H5的标签语义化：根据H5新定义，默认可点击的元素有a标签和button标签，也就是给这两种标签进行事件委托是完全没有问题的。由此解决的办法有：第一种：换dom结构完全按照语意规定，点击元素使用button，超链使用a标签。第二种：把document换成selector的父元素，前提是父元素不是由JS生成的。第三种：解决的方法很巧妙，就是给需要绑定事件的元素添加一个css cursor: pointer。exp:123.item &#123; cursor:pointer;&#125; 推荐使用第三种方法，灵活，好控制。需要注意的是，cursor属性是可继承的，如果点击元素还有子元素，而且需禁用事件，记得将cursor属性值设置为default。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"dom","slug":"dom","permalink":"http://yoursite.com/tags/dom/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"css垂直水平居中","slug":"2017-09-21-css垂直水平居中","date":"2017-09-21T05:19:22.000Z","updated":"2018-12-17T15:35:22.206Z","comments":true,"path":"2017/09/21/2017-09-21-css垂直水平居中/","link":"","permalink":"http://yoursite.com/2017/09/21/2017-09-21-css垂直水平居中/","excerpt":"","text":"固定宽高div垂直居中 不定宽高垂直居中方法一：伪元素法。使用一个伪元素+inline-block/vertical-align使之居中。这个方法要求待居中的元素要是inline-block,所以不是很通用。 方法二：使用table布局。 方法三：flex布局 方法四：translate居中","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"搭建舒适的前端开发环境","slug":"2017-09-18-搭建舒适的前端开发环境","date":"2017-09-18T08:22:41.000Z","updated":"2018-12-17T15:35:22.206Z","comments":true,"path":"2017/09/18/2017-09-18-搭建舒适的前端开发环境/","link":"","permalink":"http://yoursite.com/2017/09/18/2017-09-18-搭建舒适的前端开发环境/","excerpt":"","text":"虽然现在前端领域有很多新的尝试，但是像es6这种新的东西很多低版本浏览器还是不支持，这样开发者只能墨守成规，使用原生js进行开发，但是这样使得开发效率还是没有什么变化，同时新的东西用不了，学了也是白学。此篇文章就是解决此类问题，让我们一步步打开新世界的大门吧。 开启钥匙 webpack 想必大家都应该听过webpack吧，在以往前端自动化构建工具有gulp，grunt。但是此类的工具对新手要求高，webpack以模块为思想，认为一切皆模块，所有的文件都可以通过webpack打包成模块。1、首先要安装node，此不略过。然后全局安装webpack 1npm install webpack 2、创建app-cli工程 123mkdir app-clicd app-clinpm init 3、创建如下工程结构 12345678910app-cli--src --images --scripts --styles --views--static.babelrcpackage.jsonwebpack.config.js 4、在webpack.config.js中编写如下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980let path = require('path');let webpack = require('webpack');let HtmlWebpackPlugin = require('html-webpack-plugin');let ExtractTextPlugin = require('extract-text-webpack-plugin');let CopyWebpackPlugin = require('copy-webpack-plugin');module.exports = &#123; entry: &#123; index: path.resolve(__dirname, 'src', 'scripts', 'index.js'), //second: path.resolve(__dirname, 'src', 'scripts', 'second.js'), //多个页面添加入口 &#125;, output: &#123; filename: 'scripts/[name]-[hash].js', chunkFilename: \"scripts/[name].chunk.js\", path: path.resolve(__dirname, 'dist'), /*publicPath: \"/dist/\"*/ &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, loader: 'babel-loader', include: path.resolve(__dirname, 'src', 'scripts') &#125;, &#123; test: /\\.(scss|css)$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: ['css-loader','sass-loader'] &#125;), include: path.resolve(__dirname, 'src', 'styles') &#125;, &#123; test: /\\.(png|jpg|gif)$/, loader: 'url-loader', query: &#123; limit: 10000, name: 'img/[name].[hash:8].[ext]' &#125; &#125; ] &#125;, plugins: [ /* new webpack.optimize.UglifyJsPlugin(&#123; //代码压缩 compress: &#123; warnings: false &#125; &#125;),*/ new ExtractTextPlugin(&#123; filename: './styles/[name].css', &#125;), //单独打包css new CopyWebpackPlugin([&#123; //合并static文件下文件 from: path.resolve(__dirname, 'static'), to: path.resolve(__dirname, 'dist', 'static'), ignore: ['.*'] &#125;]), new HtmlWebpackPlugin(&#123; filename: index1.html, template: path.resolve(__dirname, 'src', 'views', 'index.html'), inject: 'body', hash: true, chunks: ['index'], minify: &#123; removeComments: true, collapseWhitespace: false &#125; &#125;), /*new HtmlWebpackPlugin(&#123; //多个页面添加入口 filename: './views/second.html', template: path.resolve(__dirname, 'src', 'views', 'second.html'), inject: 'body', hash: true, chunks: ['second'], minify: &#123; removeComments: true, collapseWhitespace: false &#125; &#125;)*/ ]&#125;; 5、在.babelrc中编写如下代码 1234567&#123; &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;modules&quot;: false &#125;] ]&#125; 6、在package.json编写如下代码 12345678910111213141516171819202122232425262728&#123; \"name\": \"app-cli\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack-dev-server --hot --inline --port 3003\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"babel-core\": \"^6.26.0\", \"babel-loader\": \"^7.1.2\", \"babel-preset-env\": \"^1.6.0\", \"copy-webpack-plugin\": \"^4.0.1\", \"css-loader\": \"^0.28.7\", \"extract-text-webpack-plugin\": \"^3.0.0\", \"html-webpack-plugin\": \"^2.30.1\", \"node-sass\": \"^4.5.3\", \"sass-loader\": \"^6.0.6\", \"style-loader\": \"^0.18.2\", \"url-loader\": \"^0.5.9\", \"webpack\": \"^3.6.0\", \"webpack-dev-server\": \"^2.8.2\", \"zepto\": \"^1.2.0\" &#125;&#125; 进入新世界 安装和编写完上述过程后，使用 npm start 命令运行本地开发环境，本cli支持热更新，所以不需要每次手动的刷新浏览器更新代码。对于上线环境只需要使用 webpack 命令打包，打包完后所有文件都在dist文件夹中（此文件夹自动生成）。 通过使用此app-cli工具，可以在开发中使用sass和es6，一方面提高了开发效率，另一方面也将新知识带入了生产中。 详细请看 app-cli","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"将AJAX封装为fetch","slug":"2017-08-07-将AJAX封装为fetch","date":"2017-08-07T12:29:41.000Z","updated":"2018-12-17T15:35:22.205Z","comments":true,"path":"2017/08/07/2017-08-07-将AJAX封装为fetch/","link":"","permalink":"http://yoursite.com/2017/08/07/2017-08-07-将AJAX封装为fetch/","excerpt":"","text":"在日常开发中我们可能需要使用ajax来异步请求后台数据，但我们不想将jquery或者zepto全部引用进来。在vue或者react框架开发中我们一般都是使用axios这个异步请求库，此库虽好，但我们完全可以自己封装一个简单可以满足自己日常需求的ajax库。 传统ajax封装 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//fetch.jsexport default fetch = (obj = &#123;&#125;) =&gt; &#123; let obj = obj; obj.type = obj.type || 'post'; obj.url = obj.url || ''; obj.async = obj.async || true; obj.data = obj.data || null; obj.success = obj.success || function () &#123;&#125;; obj.error = obj.error || function () &#123;&#125;; let xmlHttp = null; if (XMLHttpRequest) &#123; xmlHttp = new XMLHttpRequest(); &#125;else &#123; xmlHttp = new ActiveXObject('Microsoft.XMLHTTP'); &#125; let params = []; for (let key in obj.data) &#123; params.push(key+'='+obj.data[key]); &#125; let postData = params.join('&amp;'); if (obj.type.toUpperCase() === 'POST') &#123; xmlHttp.open(obj.type,obj.url,obj.async); xmlHttp.setRequestHeader('Content-type','application/x-www-form=urlencoded;charset=utf-8'); xmlHttp.send(postData); &#125;else if (obj.type.toUpperCase() === 'GET') &#123; xmlHttp.open(obj.type,obj.url+'?'+postData,obj.async); xmlHttp.send(null); &#125; xmlHttp.onreadystatechange = () =&gt; &#123; if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200)&#123; obj.success(xmlHttp.responseText); &#125;else &#123; obj.error(xmlHttp.responseText); &#125; &#125;;&#125;//使用方法import fetch from 'fetch.js';fetch(&#123; type: 'post', url: 'baidu', async: 'true',//可以不写 data: &#123; 'data1': 1 &#125;, success: function(res) &#123; console.log(res); &#125;, error: function(err) &#123; console.log(err); &#125;&#125;); 这个库只是简单讲xmlHttp对象进行了封装，方便使用。但在支持fetch API的浏览器中还不是最优的。 进一步对AJAX封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//fetch.jsexport default async(type = 'GET', url = '', data = &#123;&#125;, method = 'fetch') =&gt; &#123; type = type.toUpperCase(); if (type == 'GET') &#123; let dataStr = ''; //数据拼接字符串 Object.keys(data).forEach(key =&gt; &#123; dataStr += key + '=' + data[key] + '&amp;'; &#125;); if (dataStr !== '') &#123; dataStr = dataStr.substr(0, dataStr.lastIndexOf('&amp;')); url = url + '?' + dataStr; &#125; &#125; if (window.fetch &amp;&amp; method == 'fetch') &#123;//对支持fetch的浏览器使用 let requestConfig = &#123; credentials: 'include',//跨域发送cookie method: type, headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json' &#125;, mode: \"cors\", cache: \"force-cache\" &#125;; if (type == 'POST') &#123; Object.defineProperty(requestConfig, 'body', &#123; value: JSON.stringify(data) &#125;); &#125; try &#123; let response = await fetch(url, requestConfig); let responseJson = await response.json(); &#125; catch (error) &#123; throw new Error(error) &#125; return responseJson &#125; else &#123; let requestObj; if (window.XMLHttpRequest) &#123; requestObj = new XMLHttpRequest(); &#125; else &#123; requestObj = new ActiveXObject; &#125; let sendData = ''; if (type == 'POST') &#123; sendData = JSON.stringify(data); &#125; requestObj.open(type, url, true); requestObj.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); requestObj.send(sendData); requestObj.onreadystatechange = () =&gt; &#123; if (requestObj.readyState == 4) &#123; if (requestObj.status == 200) &#123; let obj = requestObj.response; if (typeof obj !== 'object') &#123; obj = JSON.parse(obj); &#125; return obj; &#125; else &#123; throw new Error(requestObj); &#125; &#125; &#125; &#125;&#125;//使用方法import fetch from 'fetch.js';let getData = () =&gt; fetch('post','baidu',&#123; data1: 1&#125;);getData().then((res)=&gt; &#123; console.log(res)&#125;,(err)=&gt;&#123; console.log(err)&#125;); 上面的fetch库遵循es6最新的async编程，它会每次返回promise对象，这样使得异步不会进行深度的嵌套。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"AJAX请求时响应成功执行error的问题","slug":"2017-08-01-AJAX请求时响应成功执行error的问题","date":"2017-08-01T08:22:41.000Z","updated":"2018-12-17T15:35:22.205Z","comments":true,"path":"2017/08/01/2017-08-01-AJAX请求时响应成功执行error的问题/","link":"","permalink":"http://yoursite.com/2017/08/01/2017-08-01-AJAX请求时响应成功执行error的问题/","excerpt":"","text":"有时候我们在请求后台的时候明明已经得的了后台的相应但是没有进入success而是进入了error代码快中，处理的方法有以下几种： 将dataType:jsonp或者dataType：json改为dataType:text，这种处理方法的依据是后台返回的数据并不是json格式，这个时候我们就要将其转换为普通文本文档处理 如果上述方法无效，那就是后台设置的jsonp跨域函数不是callback，而是自定义的，我遇到的就是后台写为jsoncallback。后台的代码一般如下(php): 12345678&lt;?php $data = \".......\";$callback = $_GET['callback']; //callback为默认，我遇到就是jsoncallbackecho $callback.'('.json_encode($data).')';exit; ?&gt; 这个时候我们就将添加jsonp:callback(这里要和后台一致，默认为callback)，因为如果前端不添加这个字段就等于默认传callback，而后台获取不到自己定义的jsoncallback。这样就可以处理这个问题。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"SPA的SEO优化","slug":"2017-07-31-SPA的SEO优化","date":"2017-07-31T03:15:10.000Z","updated":"2018-12-17T15:35:22.205Z","comments":true,"path":"2017/07/31/2017-07-31-SPA的SEO优化/","link":"","permalink":"http://yoursite.com/2017/07/31/2017-07-31-SPA的SEO优化/","excerpt":"","text":"单页面的SEO一直是让人比较头疼的问题，为了解决这个问题在网上搜到了大概几种方式，最终受到启发得出一个比较优秀的方案。 目前网上流行的方法，有的是兼容了谷歌的#!的方式来让搜索引擎爬去，还有的是提交sitemap。还有一种方法就是开发两套系统，一个是让用户用，一个是服务器渲染单页的应用给搜索引擎爬虫用。 经过比较我找到一个最优的方案就是借助phantomjs,当爬虫抓取页面，那我们就把他带到phantomjs渲染好的静态html，注意，这个渲染的方法是抓取原来SPA页面的代码并运行JS，生成一个与SPA一模一样的网站，并且url(要使用这种模式 html5 history api)保持与spa完全一致。是的就这么简单就解决了，代价是与需要腾出来一个服务器搭建一个nginx作为web服务器。 入口Nginx配置123456789101112131415server &#123; listen 80; server_name www.abc.com ; location / &#123; proxy_set_header Host $host:$proxy_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #web server #当UA里面含有Baiduspider的时候，流量Nginx以反向代理的形式，将流量传递给spider_server if ($http_user_agent ~* &quot;Baidu&quot;) &#123; proxy_pass http://www.seo.com:82; &#125; proxy_pass http://www.aba.com.8:8080; &#125; &#125; web Nginx配置12345678910111213server &#123; listen 8080; server_name www.abc.com ; location / &#123; root E:\\web; index index.html index.htm; try_files $uri $uri/ /index.html; &#125; location /api &#123; proxy_pass http://192.1681.9:1335; &#125; &#125; seo Nginx配置12345678910111213listen 82; server_name www.seo.com ; location / &#123; #先访问自己的静态页面如果有直接显示 root E:\\seo; index index.html index.htm; try_files $uri $uri/index.html $uri.html @mongrel; &#125; #如果没有文件就把url发给node location @mongrel&#123; proxy_pass http://192.1681.9:3000; &#125; &#125; node express12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// ExpressJS调用方式var express = require('express');var app = express();var fs = require('fs');var path = require(\"path\");var mkdirsSync = function(dirname) &#123; //console.log(dirname); if (fs.existsSync(dirname)) &#123; return true; &#125; else &#123; if (mkdirsSync(path.dirname(dirname))) &#123; fs.mkdirSync(dirname); return true; &#125; &#125;&#125;;// 引入NodeJS的子进程模块var child_process = require('child_process');app.get('*', function(req, res) &#123; // 完整web服务器URL var url = req.protocol + '://' + '192.168.1.8:8080' + req.originalUrl; //console.log(req.originalUrl); var filePath = \"\"; var fileName = \"\"; if (req.originalUrl == '/') &#123; fileName = 'index'; filePath = \"e:/seo/\"; &#125; else &#123; var pathArray = req.originalUrl.split('/'); fileName = pathArray[pathArray.length - 1]; filePath = \"e:/seo/\" + req.originalUrl.replace(fileName, \"\") + '/'; &#125; console.log(filePath + \"....\"); // 预渲染后的页面字符串容器 var content = ''; // 开启一个phantomjs子进程 //应当先蒋策seo服务器是否存在改文件如果有直接跳转 var phantom = child_process.spawn('phantomjs', ['spider.js', url]); // 设置stdout字符编码 phantom.stdout.setEncoding('utf8'); // 监听phantomjs的stdout，并拼接起来 phantom.stdout.on('data', function(data) &#123; content += data.toString(); &#125;); // 监听子进程退出事件 phantom.on('exit', function(code) &#123; switch (code) &#123; case 1: console.log('加载失败'); res.send('加载失败'); break; case 2: console.log('加载超时: ' + url); res.send(content); break; default: var w_data = content; var w_data = new Buffer(w_data); /** * filename, 必选参数，文件名 * data, 写入的数据，可以字符或一个Buffer对象 * [options],flag,mode(权限),encoding * callback 读取文件后的回调函数，参数默认第一个err,第二个data 数据 */ mkdirsSync(filePath, '0777'); console.log(filePath + fileName + '.html'); fs.writeFile(filePath + fileName + '.html', w_data, &#123; flag: 'w' &#125;, function(err) &#123; if (err) &#123; console.error(err); &#125; else &#123; console.log('写入成功'); &#125; &#125;); res.send(content); break; &#125; &#125;);&#125;);app.listen(3000); phantomjs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/*global phantom*/\"use strict\";// 单个资源等待时间，避免资源加载后还需要加载其他资源var resourceWait = 500;var resourceWaitTimer;// 最大等待时间var maxWait = 5000;var maxWaitTimer;// 资源计数var resourceCount = 0;// PhantomJS WebPage模块var page = require('webpage').create();// NodeJS 系统模块var system = require('system');// 从CLI中获取第二个参数为目标URLvar url = system.args[1];// 设置PhantomJS视窗大小page.viewportSize = &#123; width: 1280, height: 1014&#125;;// 获取镜像var capture = function(errCode) &#123; // 外部通过stdout获取页面内容 console.log(page.content); // 清除计时器 clearTimeout(maxWaitTimer); // 任务完成，正常退出 phantom.exit(errCode);&#125;;// 资源请求并计数page.onResourceRequested = function(req) &#123; resourceCount++; clearTimeout(resourceWaitTimer);&#125;;// 资源加载完毕page.onResourceReceived = function(res) &#123; // chunk模式的HTTP回包，会多次触发resourceReceived事件，需要判断资源是否已经end if (res.stage !== 'end') &#123; return; &#125; resourceCount--; if (resourceCount === 0) &#123; // 当页面中全部资源都加载完毕后，截取当前渲染出来的html // 由于onResourceReceived在资源加载完毕就立即被调用了，我们需要给一些时间让JS跑解析任务 // 这里默认预留500毫秒 resourceWaitTimer = setTimeout(capture, resourceWait); &#125;&#125;;// 资源加载超时page.onResourceTimeout = function(req) &#123; resouceCount--;&#125;;// 资源加载失败page.onResourceError = function(err) &#123; resourceCount--;&#125;;// 打开页面page.open(url, function(status) &#123; if (status !== 'success') &#123; phantom.exit(1); &#125; else &#123; // 当改页面的初始html返回成功后，开启定时器 // 当到达最大时间（默认5秒）的时候，截取那一时刻渲染出来的html maxWaitTimer = setTimeout(function() &#123; capture(2); &#125;, maxWait); &#125;&#125;); 本篇笔记参考至北方蜘蛛的简书笔记","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"SEO","slug":"SEO","permalink":"http://yoursite.com/tags/SEO/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"React路由实践","slug":"2017-07-28-React路由实践","date":"2017-07-28T07:15:10.000Z","updated":"2018-12-17T15:35:22.204Z","comments":true,"path":"2017/07/28/2017-07-28-React路由实践/","link":"","permalink":"http://yoursite.com/2017/07/28/2017-07-28-React路由实践/","excerpt":"","text":"What is React?React是一个专注于视图层的前端框架，利用它自身的jsx模板语法可以很快速的搭建自己的前端页面。 How use router of React？实现React的路由需要使用到react-router和react-router-dom模块。 123$ npm install react-router $ npm install react-router-dom 特别注意的是reat-router从4.0开始api发生了很大的变化（这是一个大坑)，但是之前的也是可以用的 当我们安装好这两个包后，不需要两个都进行引入，只需要引入react-router-dom就好了。然后创建Router文件夹并在下面创建Router.jsx文件，编写代码如下：12345678910111213141516import React,&#123;Component&#125;from \"react\";import &#123;BrowserRouter,HashRouter,Redirect,Route,Router&#125; from \"react-router-dom\";import messageCheck from \"../component/MessageCheck\";import App from \"../app\";const history = BrowserRouter;const RouteConfig = ( &lt;HashRouter history=&#123;history&#125;&gt; &lt;App&gt; &lt;Route path=\"/\" component=&#123;messageCheck&#125;/&gt; &lt;Route path=\"messageCheck\" component=&#123;messageCheck&#125;/&gt; &lt;Redirect from='*' to='/'/&gt; &lt;/App&gt; &lt;/HashRouter&gt;);export default RouteConfig; 这里需要注意Route不能是直系子节点，必须在外面在插一个组件。可以创建App.jsx文件，也可以使用下面方法：1234567class Roots extends Component &#123; render() &#123; return ( &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; ) &#125;&#125; 然后将12345678最后在index.js文件中引入Router.jsx文件的外漏常量RouteConfig.代码如下：```javascriptimport React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import route from &apos;./router/Router&apos;ReactDOM.render(route, document.getElementById(&apos;root&apos;)); 结束语目前路由还不能实现懒加载，在react-router4.0后实现懒加载发生了很大的变化，需要的创建bundle.js实现。下次再写懒加载。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"使用webpack实现按需加载","slug":"2017-03-02-使用webpack实现按需加载","date":"2017-03-02T13:22:41.000Z","updated":"2018-12-17T15:35:22.204Z","comments":true,"path":"2017/03/02/2017-03-02-使用webpack实现按需加载/","link":"","permalink":"http://yoursite.com/2017/03/02/2017-03-02-使用webpack实现按需加载/","excerpt":"","text":"在vue和react开发单页应用的时候必须要用到路由加载，如果我们一次性打包加载所有的页面，必然导致用户在进入首页的时候发生加载很慢，甚至很卡的效果，这样会使用户的体验大大降低。经过Google后发现webpack是可以让文件进行按需加载的。这就要使用到require.ensure()这个方法。 当然它这个按需加载还可以加载js、css等很多文件。它会给里面require的文件单独打包，不和主文件打包在一起，webpack会自动配置名字，如0.js,1.js,但是这样看着不是很直观，所以要自己配置单独打包的chunk名字。 比如这里我们要打包一个.vue或者.jsx文件，代码一般如下: 123456789101112resolve =&gt; require.ensure([], () =&gt; resolve(require('../page/points/points.vue')), 'points')cb =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../Component/chooseProducts.jsx').default) &#125;,'chooseProducts')require.ensure([],function()&#123; var $=require('jquery') console.log($(\"body\")); require(\"./c\");&#125;,\"oth\"); 这里有三个参数，第一个参数是个数组，标明依赖的模块，这些会提前加载，第二个是回调函数，在这个回调函数里面的require的文件会被单独打包成一个chunk,不会和主文件打包在一起，这样就生成了两个chunk,第一次加载时只加载主文件，当点击时就会加载单独打包的chunk。这里如果想要使用自己定义的名字就需要配置chunkFilename,和publicPath,按需加载单独打包出来的chunk是以publicPath会基准来存放的。另外还要配置chunkFilename:[name].js这样才会最终生成正确的路径和名字。 配置代码: 123456output: &#123; publicPath: '/pxq/dist/', //编译好的文件，在服务器的路径,这是静态资源引用路径 path: path.resolve(__dirname,\"./dist\"), //编译到当前目录 filename: '[name].js', //编译后的文件名字 chunkFilename: '[name].[chunkhash:5].min.js', &#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]}]}